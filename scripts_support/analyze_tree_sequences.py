#!/usr/bin/env python3
"""
Tree Sequence Analysis Script

This script analyzes tree sequence files generated by msprime simulations to extract:
1. IBD segments above a specified length threshold (in cM)
2. Pairwise MRCA (Most Recent Common Ancestor) nodes 
3. Pairwise TMRCA (Time to Most Recent Common Ancestor) values

Usage:
    python analyze_tree_sequences.py [OPTIONS]

Options:
    --results-dir PATH         Directory with tree sequence files [default: results]
    --output-dir PATH          Directory to save analysis results [default: same as results-dir]
    --min-segment-length FLOAT Minimum IBD segment length in cM [default: 3.0]
    --replicate INT            Specific replicate to analyze [default: analyze all]
    --max-time FLOAT           Maximum time to look back for IBD segments [default: 50]
    --log-level STRING         Logging level (DEBUG, INFO, WARNING, ERROR) [default: INFO]
    --genetic-map STRING       Genetic map name [default: HapMapII_GRCh38]
    --chromosome-lengths FILE  File with chromosome lengths [default: built-in values]
"""

import os
import sys
import logging
import argparse
import glob
from pathlib import Path
import json
from collections import defaultdict

import numpy as np
import pandas as pd
import tskit
import msprime
import stdpopsim

from intervaltree import IntervalTree


def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="Analyze tree sequence files")
    parser.add_argument("--results-dir", type=str, default="results",
                        help="Directory with tree sequence files")
    parser.add_argument("--output-dir", type=str, default=None,
                        help="Directory to save analysis results")
    parser.add_argument("--min-segment-length", type=float, default=3.0,
                        help="Minimum IBD segment length in cM")
    parser.add_argument("--replicate", type=int, default=None,
                        help="Specific replicate to analyze (default: analyze all)")
    parser.add_argument("--max-time", type=float, default=50,
                        help="Maximum time to look back for IBD segments")
    parser.add_argument("--log-level", type=str, default="INFO",
                        choices=["DEBUG", "INFO", "WARNING", "ERROR"],
                        help="Logging level")
    parser.add_argument("--genetic-map", type=str, default="HapMapII_GRCh38",
                        help="Genetic map name")
    parser.add_argument("--chromosome-lengths", type=str, default=None,
                        help="File with chromosome lengths")
    
    return parser.parse_args()


def configure_logging(log_level="INFO"):
    """Configure logging for the script."""
    numeric_level = getattr(logging, log_level.upper(), logging.INFO)
    logging.basicConfig(
        level=numeric_level,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout)
        ]
    )


def get_chromosome_lengths():
    """Return a dictionary of chromosome lengths for GRCh38."""
    return {
        1: 248956422, 2: 242193529, 3: 198295559, 4: 190214555, 5: 181538259,
        6: 170805979, 7: 159345973, 8: 145138636, 9: 138394717, 10: 133797422,
        11: 135086622, 12: 133275309, 13: 114364328, 14: 107043718, 15: 101991189,
        16: 90338345, 17: 83257441, 18: 80373285, 19: 58617616, 20: 64444167,
        21: 46709983, 22: 50818468
    }


def load_chromosome_lengths(file_path):
    """Load chromosome lengths from a file."""
    try:
        with open(file_path, 'r') as f:
            return json.load(f)
    except Exception as e:
        logging.error(f"Error loading chromosome lengths: {e}")
        logging.info("Using default chromosome lengths")
        return get_chromosome_lengths()


def bp_to_cm(bp_length, chrom_num, genetic_map_name="HapMapII_GRCh38"):
    """
    Convert base pair length to centiMorgans using a genetic map.
    This is an approximate conversion using average recombination rates.
    """
    # Get average recombination rate from stdpopsim
    species = stdpopsim.get_species("HomSap")
    genetic_map = species.get_genetic_map(genetic_map_name)
    
    try:
        # Get chromosome-specific rate map
        rate_map = genetic_map.get_chromosome_map(f"chr{chrom_num}")
        # Use mean recombination rate (Morgan/bp) for conversion
        mean_rate = rate_map.mean_rate
        # Convert to centiMorgans (1 Morgan = 100 cM)
        cm_length = bp_length * mean_rate * 100
        return cm_length
    except Exception as e:
        logging.warning(f"Error getting recombination rate for chromosome {chrom_num}: {e}")
        # Fallback to standard approximation: 1cM â‰ˆ 1Mb
        return bp_length / 1e6


def identify_chromosome(position, conversion_dict):
    """Identify which chromosome a position belongs to."""
    for (start, end), chrom in conversion_dict.items():
        if start <= position < end:
            return chrom, start
    return None, None


def extract_ibd_segments(ts, min_segment_length_cm, max_time, chrom_lengths, genetic_map_name):
    """
    Extract IBD segments from a tree sequence with the specific format requested.
    
    Args:
        ts: Tree sequence object
        min_segment_length_cm: Minimum segment length in centiMorgans
        max_time: Maximum time to look back
        chrom_lengths: Dictionary of chromosome lengths
        genetic_map_name: Name of genetic map to use
        
    Returns:
        DataFrame with IBD segments in the requested format
    """
    logging.info("Extracting IBD segments...")
    
    # Create a conversion dictionary for chromosome positions
    conversion_dict = {}
    current_pos = 0
    for chrom, length in chrom_lengths.items():
        conversion_dict[(current_pos, current_pos + length)] = chrom
        current_pos += length + 1  # +1 for the break between chromosomes
    
    # Convert min_segment_length from cM to bp (approximate)
    min_segment_length_bp = min_segment_length_cm * 1e6
    
    # Get IBD segments
    ibd_segments = ts.ibd_segments(
        min_span=min_segment_length_bp,
        max_time=max_time,
        store_pairs=True,
        store_segments=True
    )
    
    # Create node-to-individual mapping
    node_to_ind = {}
    
    # Map each node to its individual
    for ind in ts.individuals():
        for node in ind.nodes:
            node_to_ind[node] = ind.id
    
    # Process IBD segments
    segment_data = []
    for pair, segments in ibd_segments.items():
        node1, node2 = pair
        
        # Get individual IDs
        ind1_id = node_to_ind.get(node1, -1)
        ind2_id = node_to_ind.get(node2, -1)
        
        for segment in segments:
            # Determine chromosome and position within chromosome
            chrom, chrom_start = identify_chromosome(segment.left, conversion_dict)
            if chrom is None:
                continue
                
            # Calculate local positions
            local_left = segment.left - chrom_start
            local_right = segment.right - chrom_start
            local_span = segment.span
            
            # Convert span to cM
            span_cm = bp_to_cm(local_span, chrom, genetic_map_name)
            
            # Get MRCA for this segment
            tree = ts.at(segment.left)
            mrca_node = tree.mrca(node1, node2)
            tmrca = tree.time(mrca_node) if mrca_node != tskit.NULL else np.nan
            
            # Get MRCA individual if available
            mrca_individual_id = -1
            if mrca_node != tskit.NULL:
                mrca_ind = ts.node(mrca_node).individual
                if mrca_ind != tskit.NULL:
                    mrca_individual_id = mrca_ind
            
            # Add to results
            segment_data.append({
                'individual1_id': int(ind1_id),
                'node1': int(node1),
                'individual2_id': int(ind2_id),
                'node2': int(node2),
                'chromosome': chrom,
                'start_bp': local_left,
                'end_bp': local_right,
                'length_bp': local_span,
                'length_cm': span_cm,
                'mrca_individual_id': mrca_individual_id,
                'mrca_node': mrca_node,
                'tmrca': tmrca
            })
    
    # Create DataFrame
    if segment_data:
        df = pd.DataFrame(segment_data)
        # Filter by actual cM length now that we have proper conversions
        df = df[df['length_cm'] >= min_segment_length_cm]
        # Ensure specific column order
        columns = ['individual1_id', 'node1', 'individual2_id', 'node2', 
                  'chromosome', 'start_bp', 'end_bp', 'length_bp', 'length_cm', 
                  'mrca_individual_id', 'mrca_node', 'tmrca']
        return df[columns]
    else:
        return pd.DataFrame(columns=[
            'individual1_id', 'node1', 'individual2_id', 'node2',
            'chromosome', 'start_bp', 'end_bp', 'length_bp', 'length_cm',
            'mrca_individual_id', 'mrca_node', 'tmrca'
        ])


def calculate_comprehensive_pairwise_mrca(ts, ibd_segments_df=None, ibd_segments_file=None):
    """
    Calculate all distinct MRCAs for each pair of samples from IBD segments,
    using the simplified format with individual and node IDs.
    
    Args:
        ts: Tree sequence object
        ibd_segments_df: DataFrame with IBD segments (optional)
        ibd_segments_file: Path to CSV file with IBD segments (optional)
        
    Returns:
        DataFrame with comprehensive pairwise MRCA information
    """
    # Load IBD segments from file if provided
    if ibd_segments_df is None and ibd_segments_file is not None:
        logging.info(f"Loading IBD segments from {ibd_segments_file}")
        ibd_segments_df = pd.read_csv(ibd_segments_file)
    elif ibd_segments_df is None:
        logging.error("Either ibd_segments_df or ibd_segments_file must be provided")
        return pd.DataFrame(columns=[
            'individual1_id', 'node1', 'individual2_id', 'node2',
            'mrca_individual_id', 'mrca_node', 'tmrca', 
            'total_length_bp', 'covered_regions'
        ])
    
    logging.info("Calculating comprehensive pairwise MRCA information...")
    
    # Extract unique pairs from IBD segments
    if len(ibd_segments_df) == 0:
        return pd.DataFrame(columns=[
            'individual1_id', 'node1', 'individual2_id', 'node2',
            'mrca_individual_id', 'mrca_node', 'tmrca', 
            'total_length_bp', 'covered_regions'
        ])
    
    # Ensure node IDs are integers
    ibd_segments_df['node1'] = ibd_segments_df['node1'].astype(int)
    ibd_segments_df['node2'] = ibd_segments_df['node2'].astype(int)
    
    # Create a mapping from nodes to individuals if not in the dataframe
    node_to_ind = {}
    if 'individual1_id' not in ibd_segments_df.columns:
        for ind in ts.individuals():
            for node in ind.nodes:
                node_to_ind[node] = ind.id
    
    # For each pair, we'll track the genomic intervals where each MRCA applies
    pair_mrca_intervals = defaultdict(lambda: defaultdict(list))
    
    # Store individual info for each pair
    pair_info = {}
    
    # Process each IBD segment
    for _, segment in ibd_segments_df.iterrows():
        node1 = int(segment['node1'])
        node2 = int(segment['node2'])
        pair = (min(node1, node2), max(node1, node2))  # Ensure consistent ordering
        
        # Store individual information
        if pair not in pair_info:
            if 'individual1_id' in segment:
                ind1_id = segment['individual1_id']
                ind2_id = segment['individual2_id']
            else:
                ind1_id = node_to_ind.get(node1, -1)
                ind2_id = node_to_ind.get(node2, -1)
            
            pair_info[pair] = {
                'individual1_id': ind1_id,
                'node1': node1,
                'individual2_id': ind2_id,
                'node2': node2
            }
        
        # Get the tree at this segment
        tree = ts.at(segment['start_bp'])
        mrca_node = tree.mrca(node1, node2)
        
        if mrca_node != tskit.NULL:
            start = segment['start_bp']
            end = segment['end_bp']
            # Add this interval to the MRCA's list for this pair
            pair_mrca_intervals[pair][mrca_node].append((start, end))
    
    # Now process the intervals to find the non-redundant MRCAs
    results = []
    
    for pair, mrca_intervals in pair_mrca_intervals.items():
        # Get the pair information
        pair_data = pair_info[pair]
        
        # Create interval trees for each MRCA
        mrca_trees = {}
        for mrca, intervals in mrca_intervals.items():
            tree = IntervalTree()
            for start, end in intervals:
                tree[start:end] = mrca
            mrca_trees[mrca] = tree
        
        # Find all time points (MRCAs)
        mrca_times = {}
        for mrca in mrca_intervals.keys():
            # Sample a tree where this MRCA exists
            sample_interval = mrca_intervals[mrca][0]
            sample_point = (sample_interval[0] + sample_interval[1]) / 2
            tree = ts.at(sample_point)
            mrca_times[mrca] = tree.time(mrca)
        
        # For each MRCA, calculate the total region it covers exclusively
        for mrca, intervals in mrca_intervals.items():
            # Convert intervals to a set for easier operations
            mrca_regions = IntervalTree()
            for start, end in intervals:
                mrca_regions[start:end] = mrca
            
            # Remove regions covered by more recent MRCAs
            for other_mrca, other_time in mrca_times.items():
                if other_mrca != mrca and other_time < mrca_times[mrca]:
                    # This is a more recent MRCA, remove its regions
                    other_regions = mrca_trees[other_mrca]
                    
                    # We need to work with copies to avoid modifying during iteration
                    to_remove = []
                    to_add = []
                    
                    for interval in mrca_regions:
                        overlaps = other_regions.overlap(interval.begin, interval.end)
                        for overlap in overlaps:
                            # Mark this interval for removal
                            to_remove.append(interval)
                            
                            # Create new intervals for non-overlapping parts
                            if interval.begin < overlap.begin:
                                to_add.append((interval.begin, overlap.begin, interval.data))
                            if interval.end > overlap.end:
                                to_add.append((overlap.end, interval.end, interval.data))
                    
                    # Apply the changes
                    for interval in to_remove:
                        mrca_regions.remove(interval)
                    for begin, end, data in to_add:
                        mrca_regions[begin:end] = data
            
            # Calculate total bp covered by this MRCA exclusively
            total_bp = sum(interval.end - interval.begin for interval in mrca_regions)
            
            # Create a string representation of the covered regions
            covered_regions = ';'.join([f"{int(interval.begin)}-{int(interval.end)}" 
                                      for interval in sorted(mrca_regions)])
            
            # Get MRCA individual if available
            mrca_individual_id = -1
            if mrca != tskit.NULL:
                mrca_ind = ts.node(mrca).individual
                if mrca_ind != tskit.NULL:
                    mrca_individual_id = mrca_ind
            
            # Add to results if there's any exclusive coverage
            if total_bp > 0:
                result_row = {
                    **pair_data,  # Include individual and node IDs
                    'mrca_individual_id': mrca_individual_id,
                    'mrca_node': mrca,
                    'tmrca': mrca_times[mrca],
                    'total_length_bp': total_bp,
                    'covered_regions': covered_regions
                }
                
                results.append(result_row)
    
    # Create DataFrame and ensure column order
    if results:
        df = pd.DataFrame(results)
        columns = [
            'individual1_id', 'node1', 'individual2_id', 'node2',
            'mrca_individual_id', 'mrca_node', 'tmrca', 
            'total_length_bp', 'covered_regions'
        ]
        return df[columns]
    else:
        return pd.DataFrame(columns=[
            'individual1_id', 'node1', 'individual2_id', 'node2',
            'mrca_individual_id', 'mrca_node', 'tmrca', 
            'total_length_bp', 'covered_regions'
        ])


def analyze_tree_sequence(ts_file, min_segment_length_cm, max_time, chrom_lengths, genetic_map_name, output_dir):
    """
    Analyze a single tree sequence file with enhanced individual and haplotype information.
    
    Args:
        ts_file: Path to tree sequence file
        min_segment_length_cm: Minimum segment length in centiMorgans
        max_time: Maximum time to look back
        chrom_lengths: Dictionary of chromosome lengths
        genetic_map_name: Name of genetic map to use
        output_dir: Directory to save output files
        
    Returns:
        Tuple of (ibd_output_path, mrca_output_path)
    """
    logging.info(f"Analyzing tree sequence file: {ts_file}")
    
    # Extract replicate number from filename
    try:
        replicate = int(os.path.basename(ts_file).split("_")[-1].split(".")[0])
        logging.info(f"Processing replicate {replicate}")
    except:
        replicate = os.path.basename(ts_file)
        logging.info(f"Processing file {replicate}")
    
    # Define output file paths
    ibd_output = os.path.join(output_dir, f"ibd_segments_rep_{replicate}.csv")
    mrca_output = os.path.join(output_dir, f"pairwise_mrca_rep_{replicate}.csv")
    
    # Load tree sequence
    ts = tskit.load(ts_file)
    logging.info(f"Loaded tree sequence with {ts.num_samples} samples, "
                 f"{ts.num_trees} trees, {ts.num_mutations} mutations")
    
    # Extract IBD segments with enhanced info and save immediately
    ibd_df = extract_ibd_segments(ts, min_segment_length_cm, max_time, chrom_lengths, genetic_map_name)
    logging.info(f"Found {len(ibd_df)} IBD segments â‰¥ {min_segment_length_cm} cM")
    
    # Save IBD segments immediately
    ibd_df.to_csv(ibd_output, index=False)
    logging.info(f"Saved IBD segments to {ibd_output}")
    
    # Calculate comprehensive MRCA information using the saved file
    mrca_df = calculate_comprehensive_pairwise_mrca(ts, ibd_df)
    logging.info(f"Calculated MRCA for {len(mrca_df)} sample pairs")
    
    # Save MRCA results
    mrca_df.to_csv(mrca_output, index=False)
    logging.info(f"Saved pairwise MRCA information to {mrca_output}")
    
    return ibd_output, mrca_output


def main():
    """Main function."""
    args = parse_arguments()
    
    # Configure logging
    configure_logging(args.log_level)
    
    # Set up output directory
    results_dir = args.results_dir
    output_dir = args.output_dir if args.output_dir else results_dir
    os.makedirs(output_dir, exist_ok=True)
    
    # Load chromosome lengths
    if args.chromosome_lengths:
        chrom_lengths = load_chromosome_lengths(args.chromosome_lengths)
    else:
        chrom_lengths = get_chromosome_lengths()
    
    # Find tree sequence files
    if args.replicate is not None:
        ts_files = [os.path.join(results_dir, f"msprime_tree_replicate_{args.replicate}.trees")]
    else:
        ts_files = glob.glob(os.path.join(results_dir, "msprime_tree_replicate_*.trees"))
    
    if not ts_files:
        logging.error(f"No tree sequence files found in {results_dir}")
        sys.exit(1)
    
    logging.info(f"Found {len(ts_files)} tree sequence files to analyze")
    
    # Process each file
    for ts_file in ts_files:
        # Analyze tree sequence (files are saved within the function)
        ibd_output, mrca_output = analyze_tree_sequence(
            ts_file, 
            args.min_segment_length, 
            args.max_time,
            chrom_lengths,
            args.genetic_map,
            output_dir
        )


if __name__ == "__main__":
    main()