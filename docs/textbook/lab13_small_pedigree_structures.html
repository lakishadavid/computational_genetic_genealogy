<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lab 13: Small Pedigree Structures | Computational Genetic Genealogy</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Open+Sans:wght@300;400;600&display=swap" rel="stylesheet">
</head>
<body class="textbook-page">
    <header class="textbook-header">
        <div class="container">
            <h1>Computational Genetic Genealogy</h1>
            <p>Connecting Individuals into Small Pedigree Structures</p>
        </div>
    </header>

    <nav class="textbook-nav">
        <div class="container">
            <a href="../index.html"><i class="fas fa-arrow-left"></i> Back to Main Page</a>
            <a href="contents.html">Table of Contents</a>
            <a href="lab13_small_pedigree_structures.html" class="active">Lab 13: Small Pedigree Structures</a>
        </div>
    </nav>

    <main class="container">
        <article class="section lab-content">
            <h2>Lab 13: Connecting Individuals into Small Pedigree Structures</h2>
            
            <div class="alert alert-info">
                <p><strong>Core Component:</strong> This lab explores how Bonsai v3 connects individuals into small pedigree structures using genetic evidence. This process is foundational to genealogical reconstruction, as it creates the basic building blocks that can be assembled into larger family networks.</p>
            </div>

            <h3>The Building Blocks of Pedigree Construction</h3>
            
            <div class="concept-section">
                <h4>Connecting Individuals Based on Genetic Evidence</h4>
                <p>In genetic genealogy, the process of connecting individuals into small pedigree structures requires:</p>
                
                <ol>
                    <li><strong>Identifying Relationship Types:</strong> Determining the most likely relationship between each pair of individuals</li>
                    <li><strong>Finding Optimal Connection Points:</strong> Determining where and how to connect individuals in a pedigree</li>
                    <li><strong>Building Coherent Structures:</strong> Ensuring the resulting small pedigree is biologically valid and consistent with genetic evidence</li>
                </ol>
                
                <p>Bonsai v3 implements this process through a sophisticated pipeline in the <code>connections.py</code> module. The core of this functionality revolves around identifying and leveraging connection points:</p>
                
                <pre><code>def connect_pedigrees_through_points(
    id1 : int,
    id2 : int,
    pid1 : Optional[int],
    pid2 : Optional[int],
    up_dct1 : dict[int, dict[int, int]],
    up_dct2 : dict[int, dict[int, int]],
    deg1 : int,
    deg2 : int,
    num_ancs : int,
    simple : bool=True,
):
    """
    Connect up_dct1 to up_dct2 through points id1 in up_dct1
    and id2 in up_dct2. Also connect through partner points
    pid1 and pid2, if indicated. Connect id1 to id2 through
    a relationship specified by (deg1, deg2, num_ancs).
    """
    # can't connect "on" genotyped nodes
    if deg1 == deg2 == 0 and (id1 > 0 and id2 > 0) and id1 != id2:
        return []

    # can't connect "on" genotyped or non-existent partner nodes
    if deg1 == deg2 == 0 and (pid1 != pid2):
        if pid1 is None or pid1 is None:
            return []
        elif pid1 > 0 and pid2 > 0:
            return []

    up_dct1 = copy.deepcopy(up_dct1)
    up_dct2 = copy.deepcopy(up_dct2)

    if deg1 > 0:
        up_dct1, _, id1, pid1 = extend_up(
            iid=id1,
            deg=deg1,
            num_ancs=num_ancs,
            up_dct=up_dct1,
        )

    if deg2 > 0:
        up_dct2, _, id2, pid2 = extend_up(
            iid=id2,
            deg=deg2,
            num_ancs=num_ancs,
            up_dct=up_dct2,
        )

    # shift IDs so that they don't overlap
    min_id = get_min_id(up_dct1)-1
    up_dct2, id_map = shift_ids(
        ped=up_dct2,
        shift=min_id,
    )
    id2 = id_map.get(id2, id2)
    pid2 = id_map.get(pid2, pid2)

    # get a mapping of IDs in up_dct1 to match
    # with IDs in up_dct2
    if simple:
        if (pid1 is not None) and (pid2 is not None):
            id_map_list = [
                {id1 : id2, pid1 : pid2}
            ]
        else:
            id_map_list = [
                {id1 : id2}
            ]
    else:
        id_map_list = get_all_matches(
            id1=id1,
            id2=id2,
            pid1=pid1,
            pid2=pid2,
            up_dct1=up_dct1,
            up_dct2=up_dct2,
        )

    # connect up_dct1 to up_dct2 in all
    # ways specified in id_map_list
    connect_dct_list = []
    for id_map in id_map_list:
        up_dct = connect_on(
            id_map=id_map,
            up_dct1=up_dct1,
            up_dct2=up_dct2,
        )
        connect_dct_list.append(up_dct)

    return connect_dct_list</code></pre>
                
                <p>This function handles the intricate process of connecting two pedigrees through specified points, taking into account:</p>
                
                <ul>
                    <li><strong>Compatibility Checks:</strong> Verifying that the proposed connection is biologically valid</li>
                    <li><strong>Extending Lineages:</strong> Building out the necessary ancestor nodes using <code>extend_up</code></li>
                    <li><strong>ID Management:</strong> Ensuring no conflicts between node IDs when combining pedigrees</li>
                    <li><strong>Multiple Connection Options:</strong> Returning alternative ways to connect the pedigrees when multiple options exist</li>
                </ul>
                
                <p>This sophisticated connection mechanism allows Bonsai v3 to construct small pedigree structures that accurately reflect genetic relationships while maintaining biological plausibility.</p>
            </div>
            
            <div class="concept-section">
                <h4>Building Basic Family Units</h4>
                <p>The foundation of pedigree construction is building basic family units - parents with children, siblings sharing parents, etc. In Bonsai v3, these operations are implemented in the <code>pedigrees.py</code> module. A key function for this purpose is <code>add_parent</code>:</p>
                
                <pre><code>def add_parent(
    node: int,
    up_dct: dict[int, dict[int, int]],
    min_id: Optional[int]=None,
):
    """
    Add an ungenotyped parent to node in up_dct.
    """
    if node not in up_dct:
        raise BonsaiError(f"Node {node} is not in up dct.")

    pid_dict = up_dct[node]
    if len(pid_dict) >= 2:
        return up_dct, None

    if min_id is None:
        min_id = get_min_id(up_dct)

    new_pid = min_id - 1
    up_dct[node][new_pid] = 1

    return up_dct, new_pid</code></pre>
                
                <p>This function adds an ungenotyped parent (i.e., a parent for whom we don't have genetic data) to a specified node in the pedigree. It's a fundamental building block for constructing family units when we have only partial data. The function:</p>
                
                <ol>
                    <li>Verifies that the node exists in the pedigree</li>
                    <li>Checks that the node doesn't already have two parents (biological maximum)</li>
                    <li>Finds an appropriate ID for the new parent (using negative IDs for ungenotyped individuals)</li>
                    <li>Adds the parent-child relationship to the pedigree</li>
                </ol>
                
                <p>Other key functions for building family units include:</p>
                
                <pre><code>def get_partner_id_set(
    node: int,
    up_dct: dict[int, dict[int, int]],
):
    """
    Find the set of partners of node in pedigree up_dct.
    
    Partners are defined as other parents of node's children.
    """
    down_dct = reverse_node_dict(up_dct)  # Get children pointing to parents
    
    # Get all children with a parent-child relationship (degree=1)
    child_id_set = {c for c, d in down_dct.get(node, {}).items() if d == 1}
    
    # For each child, get their other parents
    partner_id_set = set()
    for cid in child_id_set:
        # Get all parents of this child
        pids = {p for p, d in up_dct.get(cid, {}).items() if d == 1}
        # Add to partner set
        partner_id_set |= pids
    
    # Remove the node itself from the partner set
    partner_id_set -= {node}
    
    return partner_id_set</code></pre>
                
                <p>This function identifies partner relationships by finding other individuals who are parents of the same children. This is crucial for constructing family units because:</p>
                
                <ul>
                    <li>It identifies existing family structures without requiring explicit relationship encoding</li>
                    <li>It allows Bonsai to connect additional relatives through appropriate family units</li>
                    <li>It helps identify potential connection points for merging pedigrees</li>
                </ul>
                
                <p>Together, these building block functions enable Bonsai v3 to construct basic family units that form the foundation of larger pedigree structures.</p>
            </div>
            
            <div class="concept-section">
                <h4>Extending Lineages</h4>
                <p>Once basic family units are established, Bonsai v3 can extend these into lineages by adding ancestors or descendants. A key function for lineage extension is <code>extend_up</code>:</p>
                
                <pre><code>def extend_up(
    iid: int,
    deg: int,
    num_ancs: int,
    up_dct: dict[int, dict[int, int]],
):
    """
    Extend a lineage up from iid in up node dict up_dct.
    
    Args:
        iid: ID of individual to extend from
        deg: Number of generations to extend up
        num_ancs: Number of ancestors to add (1 or 2)
        up_dct: Up-node dictionary representing the pedigree
        
    Returns:
        up_dct: Updated pedigree with extended lineage
        node_id: ID of node from which extension began
        new_id: ID of most recent ancestor added
        part_id: ID of partner ancestor (if num_ancs=2)
    """
    if deg == 0:
        return up_dct, None, iid, None
        
    # Get minimum ID for creating new ancestors
    min_id = get_min_id(up_dct)
    new_id = min(min_id - 1, -1)  # Ensure negative ID for ungenotyped
    
    # Initialize variables
    prev_id = None
    part_id = None
    curr_id = iid
    
    # Extend lineage upward deg generations
    while deg > 0:
        # Ensure current ID exists in pedigree
        if curr_id not in up_dct:
            up_dct[curr_id] = {}
            
        # Check if can add more parents
        if len(up_dct[curr_id]) >= 2:
            raise ValueError(f"Cannot add parent to {curr_id}, already has 2 parents")
            
        # Add new ancestor as parent
        up_dct[curr_id][new_id] = 1
        if new_id not in up_dct:
            up_dct[new_id] = {}
            
        # Add partner if this is final generation and num_ancs=2
        if deg == 1 and num_ancs == 2:
            part_id = new_id - 1
            up_dct[curr_id][part_id] = 1
            if part_id not in up_dct:
                up_dct[part_id] = {}
                
        # Move up one generation
        prev_id = curr_id
        curr_id = new_id
        new_id -= 1
        deg -= 1
        
    return up_dct, prev_id, curr_id, part_id</code></pre>
                
                <p>This function extends a lineage upward by adding ungenotyped ancestors, with the ability to add either one or two ancestors at the final generation. It's essential for building connections between individuals who are separated by multiple generations. The function:</p>
                
                <ol>
                    <li>Creates a chain of ancestors for the specified number of generations</li>
                    <li>Adds either a single ancestor or a pair of ancestors (e.g., both parents) at the final generation</li>
                    <li>Manages IDs to ensure uniqueness and proper representation of ungenotyped individuals</li>
                    <li>Returns information about the added ancestors for further pedigree construction</li>
                </ol>
                
                <p>Through strategic use of <code>extend_up</code>, Bonsai v3 can build pedigree structures that span multiple generations, even when genetic data is only available for some of the individuals.</p>
            </div>

            <h3>Pedigree Connection Mechanisms</h3>
            
            <div class="concept-section">
                <h4>Finding Connection Points</h4>
                <p>A critical step in building small pedigree structures is identifying where two individuals or pedigrees can be connected. Bonsai v3 implements this through the <code>get_possible_connection_point_set</code> function:</p>
                
                <pre><code>def get_possible_connection_point_set(
    ped: dict[int, dict[int, int]],
) -> set[tuple[int, Optional[int], Optional[int]]]:
    """
    Find all possible points through which a pedigree (ped) can be connected
    to another pedigree. A point is a tuple of the form (id1, id2, dir),
    where id1 is the main individual through whom the pedigree is connected
    and id2 is a possible secondary connecting individual (always a partner of id1
    if they exist). id2 can be None. dir indicates whether the pedigree is
    connected up to the other pedigree or down to the other pedigree. 0=down
    1=up.
    """
    point_set = set()
    all_ids = get_all_id_set(ped)
    for a in all_ids:
        parent_to_deg = ped.get(a, {})
        if len(parent_to_deg) < 2:
            point_set.add((a, None, 1))

        partners = get_partner_id_set(a, ped)
        point_set.add((a, None, 0))
        for partner in partners:
            if (partner, a, 0) not in point_set:  # only need one orientation
                point_set.add((a, partner, 0))
            point_set.add((a, partner, None))  # try reverse orientation

        point_set.add((a, None, None))

    return point_set</code></pre>
                
                <p>This function identifies all potential connection points in a pedigree, returning a set of tuples that specify:</p>
                
                <ol>
                    <li><strong>Primary ID (id1):</strong> The main individual through whom the connection is made</li>
                    <li><strong>Secondary ID (id2):</strong> An optional partner of the primary individual (can be None)</li>
                    <li><strong>Direction (dir):</strong> Whether the connection is upward (1), downward (0), or lateral (None)</li>
                </ol>
                
                <p>These connection points represent all the possible ways that a pedigree can be extended or connected to another pedigree. By identifying these points, Bonsai v3 can systematically evaluate different connection options to find the one that best explains the genetic data.</p>
                
                <p>The function considers several types of connection points:</p>
                
                <ul>
                    <li><strong>Upward Connections:</strong> Individuals who can have additional parents added</li>
                    <li><strong>Downward Connections:</strong> Individuals who can have children added</li>
                    <li><strong>Partner Connections:</strong> Pairs of individuals who are partners and can have common children</li>
                    <li><strong>Lateral Connections:</strong> Points where individuals can be directly replaced or connected laterally</li>
                </ul>
                
                <p>This comprehensive approach ensures that Bonsai v3 considers all biologically plausible ways to connect pedigrees, maximizing the chance of finding the correct structure.</p>
            </div>
            
            <div class="concept-section">
                <h4>Connecting and Merging Pedigrees</h4>
                <p>Once connection points are identified, Bonsai v3 can connect and merge pedigrees to form larger structures. The <code>combine_pedigrees</code> function orchestrates this process:</p>
                
                <pre><code>def combine_pedigrees(
    up_dct1: dict[int, dict[int, int]],
    up_dct2: dict[int, dict[int, int]],
    id_to_shared_ibd: dict[tuple[int, int], list[dict]],
    id_to_info: dict[int, dict],
    pw_ll: Any,
    max_up: int = 3,
    keep_num: int = 3,
    return_many: bool = False,
):
    """
    Combine two pedigrees into one, using IBD sharing to guide the connection.
    
    Args:
        up_dct1, up_dct2: The pedigrees to combine
        id_to_shared_ibd: Dict mapping ID pairs to IBD segments
        id_to_info: Dict mapping IDs to biographical information
        pw_ll: PwLogLike instance for likelihood calculation
        max_up: Maximum number of generations to extend upward
        keep_num: Number of top combinations to keep
        return_many: Whether to return multiple possible combinations
        
    Returns:
        Combined pedigree or list of top combinations with likelihoods
    """
    # Find connections between the pedigrees based on IBD
    con_pairs = find_connecting_pairs(
        up_dct1=up_dct1,
        up_dct2=up_dct2,
        id_to_shared_ibd=id_to_shared_ibd,
        min_cm=20,
    )
    
    if not con_pairs:
        return None if not return_many else []
    
    # Get all possible connection points in each pedigree
    con_pts1 = get_possible_connection_point_set(up_dct1)
    con_pts2 = get_possible_connection_point_set(up_dct2)
    
    # Generate and evaluate all possible combinations
    top_combs = []
    for (id1, id2) in con_pairs:
        # Find connection points involving id1 and id2
        rel_con_pts1 = [pt for pt in con_pts1 if pt[0] == id1]
        rel_con_pts2 = [pt for pt in con_pts2 if pt[0] == id2]
        
        # For each pair of connection points
        for cp1 in rel_con_pts1:
            for cp2 in rel_con_pts2:
                # Try different relationship configurations
                for up in range(max_up + 1):
                    for down in range(max_up + 1):
                        if up + down > max_up:
                            continue
                        
                        # Try both 1 and 2 ancestors
                        for num_ancs in [1, 2]:
                            # Try connecting the pedigrees
                            combs = connect_pedigrees_through_points(
                                id1=cp1[0], 
                                id2=cp2[0],
                                pid1=cp1[1], 
                                pid2=cp2[1],
                                up_dct1=up_dct1, 
                                up_dct2=up_dct2,
                                deg1=up, 
                                deg2=down,
                                num_ancs=num_ancs,
                            )
                            
                            # Evaluate each combination
                            for comb in combs:
                                ll = evaluate_pedigree(
                                    ped=comb,
                                    id_to_shared_ibd=id_to_shared_ibd,
                                    id_to_info=id_to_info,
                                    pw_ll=pw_ll,
                                )
                                
                                # Add to list of top combinations
                                top_combs.append((comb, ll))
    
    # Sort by likelihood and keep top combinations
    top_combs.sort(key=lambda x: x[1], reverse=True)
    top_combs = top_combs[:keep_num]
    
    # Return results based on return_many parameter
    if return_many:
        return top_combs
    else:
        return top_combs[0][0] if top_combs else None</code></pre>
                
                <p>This function systematically:</p>
                
                <ol>
                    <li>Identifies pairs of individuals that connect the two pedigrees based on IBD sharing</li>
                    <li>Finds all possible connection points in each pedigree</li>
                    <li>Generates potential combinations by trying different relationships between connection points</li>
                    <li>Evaluates each combination based on how well it explains the observed genetic data</li>
                    <li>Returns either the best combination or a list of top combinations</li>
                </ol>
                
                <p>The function explores a comprehensive space of possible connections, considering different relationship types (varying <code>up</code>, <code>down</code>, and <code>num_ancs</code> parameters) and different connection points. This allows Bonsai v3 to find the most likely way to combine two pedigrees based on genetic evidence.</p>
                
                <p>The likelihood-based approach is crucial because it allows Bonsai v3 to:</p>
                
                <ul>
                    <li>Handle ambiguity when multiple connection options are plausible</li>
                    <li>Incorporate both genetic and non-genetic information (through <code>id_to_info</code>)</li>
                    <li>Balance complexity and explanatory power in the resulting pedigree</li>
                    <li>Maintain multiple hypotheses when certainty is low (<code>return_many=True</code>)</li>
                </ul>
                
                <p>This sophisticated mechanism for pedigree combination is at the heart of Bonsai v3's ability to reconstruct complex family structures from genetic data.</p>
            </div>
            
            <div class="concept-section">
                <h4>Filling in Missing Individuals</h4>
                <p>A critical aspect of small pedigree construction is filling in missing individuals to create biologically plausible structures. Bonsai v3 implements this through functions like <code>fill_in_partners</code>:</p>
                
                <pre><code>def fill_in_partners(
    up_dct: dict[int, dict[int, int]],
    fill_max: int = 2,
):
    """
    Fill in all missing partners in a pedigree.
    
    Args:
        up_dct: Up-node dictionary representing the pedigree
        fill_max: Maximum number of missing partners to fill in
        
    Returns:
        up_dct: Updated pedigree with partners filled in
    """
    up_dct = copy.deepcopy(up_dct)
    
    # Find individuals with exactly one parent
    for node, parents in up_dct.items():
        if len(parents) == 1:
            parent = list(parents.keys())[0]
            
            # Check if this parent already has a partner who is parent to this node
            partners = get_partner_id_set(parent, up_dct)
            needs_partner = True
            
            for partner in partners:
                if partner in parents:
                    needs_partner = False
                    break
            
            # If no existing partner is parent to this node, add a new one
            if needs_partner:
                min_id = get_min_id(up_dct)
                new_partner = min_id - 1
                
                # Add the new partner as a parent of the node
                up_dct[node][new_partner] = 1
                
                # Add the new partner to the pedigree
                if new_partner not in up_dct:
                    up_dct[new_partner] = {}
    
    return up_dct</code></pre>
                
                <p>This function identifies individuals who have only one parent recorded and adds a second parent to create biologically complete family units. This is important because:</p>
                
                <ul>
                    <li>It ensures pedigrees respect biological reality (everyone has two biological parents)</li>
                    <li>It creates more complete structures for relationship inference and connection</li>
                    <li>It provides placeholders that can be identified with real individuals as more data becomes available</li>
                </ul>
                
                <p>Other functions for filling in missing individuals include <code>fill_in_lineages</code> (which creates complete ancestral lineages) and <code>fill_in_siblings</code> (which adds ungenotyped siblings to create more complete family units).</p>
                
                <p>These functions help Bonsai v3 build small pedigree structures that are both genetically consistent and biologically complete, even when the genetic data is incomplete.</p>
            </div>

            <h3>Evaluating Pedigree Structures</h3>
            
            <div class="concept-section">
                <h4>The Likelihood Framework</h4>
                <p>A central aspect of Bonsai v3's pedigree construction is evaluating how well different structures explain the observed genetic data. This is implemented through a likelihood framework in the <code>likelihoods.py</code> module:</p>
                
                <pre><code>def get_ped_like(
    up_dct: dict[int, dict[int, int]],
    id_to_shared_ibd: dict[tuple[int, int], list[dict]],
    id_to_info: dict[int, dict],
    pw_ll: Any,
):
    """
    Calculate the likelihood of a pedigree given IBD data.
    
    Args:
        up_dct: Up-node dictionary representing the pedigree
        id_to_shared_ibd: Dict mapping ID pairs to IBD segments
        id_to_info: Dict mapping IDs to biographical information
        pw_ll: PwLogLike instance for likelihood calculation
        
    Returns:
        log_like: Log-likelihood of the pedigree
    """
    log_like = 0.0
    
    # Get all genotyped individuals in the pedigree
    all_ids = get_all_id_set(up_dct)
    gen_ids = [i for i in all_ids if i > 0]  # Genotyped IDs are positive
    
    # For each pair of genotyped individuals
    for i in range(len(gen_ids)):
        for j in range(i+1, len(gen_ids)):
            id1, id2 = gen_ids[i], gen_ids[j]
            
            # Skip if no IBD data for this pair
            pair = (min(id1, id2), max(id1, id2))
            if pair not in id_to_shared_ibd:
                continue
                
            # Get IBD data for this pair
            ibd_segs = id_to_shared_ibd[pair]
            
            # Get relationship from pedigree
            rel_tuple = get_simple_rel_tuple(up_dct, id1, id2)
            
            # Calculate likelihood of this relationship given IBD
            pair_ll = pw_ll.get_ibd_log_like(
                id1=id1,
                id2=id2,
                rel_tuple=rel_tuple,
                ibd_segs=ibd_segs,
            )
            
            # Add to total log-likelihood
            log_like += pair_ll
    
    # Add penalty for improbable age relationships
    age_ll = get_age_log_like(up_dct, id_to_info)
    log_like += age_ll
    
    return log_like</code></pre>
                
                <p>This function calculates the overall log-likelihood of a pedigree by:</p>
                
                <ol>
                    <li>Identifying all pairs of genotyped individuals in the pedigree</li>
                    <li>Determining the relationship between each pair based on the pedigree structure</li>
                    <li>Calculating how well that relationship explains the observed IBD segments</li>
                    <li>Adding penalties for biologically implausible age relationships</li>
                    <li>Combining these components into a total log-likelihood score</li>
                </ol>
                
                <p>The likelihood framework allows Bonsai v3 to quantitatively compare different pedigree structures, selecting the one that best explains the observed genetic data while respecting biological constraints.</p>
                
                <p>This approach has several key advantages:</p>
                
                <ul>
                    <li>It provides a principled basis for choosing between alternative pedigree structures</li>
                    <li>It naturally incorporates uncertainty in the genetic and biographical data</li>
                    <li>It balances genetic evidence against biological plausibility</li>
                    <li>It can be extended to include additional types of evidence as they become available</li>
                </ul>
                
                <p>By using this likelihood framework, Bonsai v3 can build small pedigree structures that optimally explain the available data, serving as reliable building blocks for larger pedigree reconstructions.</p>
            </div>
            
            <div class="concept-section">
                <h4>Comparing Alternative Structures</h4>
                <p>When building small pedigree structures, there are often multiple plausible configurations that could explain the observed genetic data. Bonsai v3 systematically compares these alternatives through functions like <code>evaluate_pedigree_set</code>:</p>
                
                <pre><code>def evaluate_pedigree_set(
    pedigree_set: list[dict[int, dict[int, int]]],
    id_to_shared_ibd: dict[tuple[int, int], list[dict]],
    id_to_info: dict[int, dict],
    pw_ll: Any,
):
    """
    Evaluate a set of alternative pedigree structures.
    
    Args:
        pedigree_set: List of pedigrees to evaluate
        id_to_shared_ibd: Dict mapping ID pairs to IBD segments
        id_to_info: Dict mapping IDs to biographical information
        pw_ll: PwLogLike instance for likelihood calculation
        
    Returns:
        evaluated_pedigrees: List of (pedigree, log_like) tuples, sorted by likelihood
    """
    evaluated_pedigrees = []
    
    # Evaluate each pedigree
    for ped in pedigree_set:
        # Calculate log-likelihood
        log_like = get_ped_like(
            up_dct=ped,
            id_to_shared_ibd=id_to_shared_ibd,
            id_to_info=id_to_info,
            pw_ll=pw_ll,
        )
        
        # Add to list of evaluated pedigrees
        evaluated_pedigrees.append((ped, log_like))
    
    # Sort by likelihood (highest first)
    evaluated_pedigrees.sort(key=lambda x: x[1], reverse=True)
    
    return evaluated_pedigrees</code></pre>
                
                <p>This function evaluates a set of alternative pedigree structures and returns them sorted by likelihood. This is crucial for Bonsai v3's approach to pedigree construction because:</p>
                
                <ul>
                    <li>It allows exploration of multiple hypotheses about how individuals might be related</li>
                    <li>It provides a principled basis for selecting the most likely structure</li>
                    <li>It quantifies the confidence in different possible structures</li>
                    <li>It allows for maintaining alternative hypotheses when the evidence is ambiguous</li>
                </ul>
                
                <p>By systematically comparing alternative structures, Bonsai v3 can identify the one that best explains the genetic data, while also maintaining awareness of other plausible configurations. This approach is essential for robust pedigree reconstruction, as it prevents premature commitment to potentially incorrect structures.</p>
                
                <p>When constructing complex pedigrees, Bonsai v3 often maintains multiple hypotheses throughout the process, only committing to specific structures when the evidence strongly supports them. This balanced approach helps navigate the inherent uncertainty in genetic genealogy, producing results that accurately reflect the confidence supported by the available data.</p>
            </div>
            
            <div class="concept-section">
                <h4>Optimizing Small Structures</h4>
                <p>Beyond evaluating fixed pedigree structures, Bonsai v3 can optimize small structures to better explain the genetic data. This is implemented through functions like <code>optimize_pedigree</code>:</p>
                
                <pre><code>def optimize_pedigree(
    up_dct: dict[int, dict[int, int]],
    id_to_shared_ibd: dict[tuple[int, int], list[dict]],
    id_to_info: dict[int, dict],
    pw_ll: Any,
    max_iterations: int = 10,
):
    """
    Optimize a small pedigree structure to better explain the genetic data.
    
    Args:
        up_dct: Initial pedigree to optimize
        id_to_shared_ibd: Dict mapping ID pairs to IBD segments
        id_to_info: Dict mapping IDs to biographical information
        pw_ll: PwLogLike instance for likelihood calculation
        max_iterations: Maximum number of optimization iterations
        
    Returns:
        optimized_ped: Optimized pedigree structure
        final_ll: Log-likelihood of the optimized pedigree
    """
    current_ped = copy.deepcopy(up_dct)
    current_ll = get_ped_like(current_ped, id_to_shared_ibd, id_to_info, pw_ll)
    
    # Optimization iterations
    for _ in range(max_iterations):
        # Generate variations of the current pedigree
        variations = generate_pedigree_variations(current_ped)
        
        # Evaluate all variations
        best_var = current_ped
        best_ll = current_ll
        
        for var in variations:
            var_ll = get_ped_like(var, id_to_shared_ibd, id_to_info, pw_ll)
            if var_ll > best_ll:
                best_var = var
                best_ll = var_ll
        
        # If no improvement, stop optimization
        if best_ll <= current_ll:
            break
            
        # Update current pedigree and likelihood
        current_ped = best_var
        current_ll = best_ll
    
    return current_ped, current_ll</code></pre>
                
                <p>This function implements an iterative optimization process that:</p>
                
                <ol>
                    <li>Starts with an initial pedigree structure</li>
                    <li>Generates variations by making small changes to the structure</li>
                    <li>Evaluates each variation to find the one with the highest likelihood</li>
                    <li>Updates the current structure if an improvement is found</li>
                    <li>Repeats until no further improvement is possible or the maximum iterations are reached</li>
                </ol>
                
                <p>The generation of variations is handled by <code>generate_pedigree_variations</code>, which creates alternative structures by:</p>
                
                <ul>
                    <li>Adding or removing ungenotyped individuals</li>
                    <li>Changing relationship types between individuals</li>
                    <li>Rearranging connections to form different family structures</li>
                    <li>Merging or splitting family units</li>
                </ul>
                
                <p>This optimization approach allows Bonsai v3 to refine initial pedigree structures to better explain the genetic data, creating small structures that more accurately reflect the true relationships between individuals.</p>
            </div>

            <div class="alert alert-success">
                <p><strong>Core Component:</strong> Bonsai v3's ability to connect individuals into small pedigree structures forms the foundation of its pedigree reconstruction capabilities. By systematically identifying connection points, evaluating alternative structures, and optimizing small pedigrees, Bonsai can build biologically plausible family units that accurately explain the genetic relationships between individuals. These small structures serve as the building blocks for larger, more complex pedigree reconstructions.</p>
            </div>
            
            <h3>Comparing Notebook and Production Code</h3>
            
            <p>The Lab13 notebook provides a simplified exploration of pedigree construction mechanisms, while the production implementation in Bonsai v3 includes additional sophistication:</p>
            
            <ul>
                <li><strong>Comprehensive Exploration:</strong> The production code systematically explores more connection points and relationship configurations</li>
                <li><strong>Sophisticated Evaluation:</strong> More nuanced likelihood models calibrated on extensive real-world data</li>
                <li><strong>Optimized Algorithms:</strong> Highly efficient implementations for handling large pedigrees with many individuals</li>
                <li><strong>Conflict Resolution:</strong> Advanced mechanisms for resolving conflicts when different genetic evidence suggests incompatible relationships</li>
                <li><strong>Uncertainty Handling:</strong> Robust representation and propagation of uncertainty throughout the pedigree construction process</li>
                <li><strong>Edge Case Handling:</strong> Special handling for complex scenarios like adoptions, half-relationships, and multiple marriages</li>
            </ul>
            
            <p>The notebook provides an educational introduction to the key concepts, but the production implementation represents years of refinement to handle the complexities of real-world genetic data and family structures.</p>

            <h3>Interactive Lab Environment</h3>
            
            <div class="jupyter-integration">
                <p>Click the button below to open the interactive Lab 13 notebook directly in your browser using JupyterLite. No installation required!</p>
                
                <div class="jupyterlite-container">
                    <div class="jupyterlite-info">
                        <h4>Browser-Based Analysis</h4>
                        <p>This link will open the <strong>Lab13_Small_Pedigree_Structures.ipynb</strong> notebook in a browser-based Jupyter environment.</p>
                        <p>You can run the code cells by clicking on them and pressing Shift+Enter.</p>
                        <p><strong>Note:</strong> Your work is automatically saved in your browser's storage. If you clear your browser data, your progress may be lost. Be sure to download your notebook periodically ('File' -> 'Download') to save your work locally.</p>
                    </div>
                    
                    <!-- This is now a link styled as a button -->
                    <a href="https://lakishadavid.github.io/computational_genetic_genealogy/jupyterlite_app/lab/index.html?path=labs_v2/Lab13_Small_Pedigree_Structures.ipynb"
                       class="open-jupyterlite-link"
                       target="_blank"
                       role="button">
                        Open Lab 13 Notebook in JupyterLite
                    </a>
                </div>
            </div>

            <h3>Beyond the Code</h3>
            <p>As you explore the mechanisms for connecting individuals into small pedigree structures, consider these broader implications:</p>
            <ul>
                <li><strong>Family Dynamics:</strong> How small pedigree structures often reflect social and cultural patterns of family formation, not just genetic relationships</li>
                <li><strong>Historical Context:</strong> How demographic factors like marriage patterns, fertility rates, and lifespan influence the structure of pedigrees across different times and populations</li>
                <li><strong>Incomplete Data:</strong> The challenges and ethical considerations of reconstructing family structures from partial genetic data, and the importance of acknowledging uncertainty</li>
                <li><strong>Privacy Considerations:</strong> How connecting individuals into family structures can reveal previously unknown relationships, with potential privacy implications</li>
                <li><strong>Cultural Variation:</strong> How family structures vary across different cultures and historical periods, and how computational methods must respect this diversity</li>
            </ul>
            <p>These considerations highlight how connecting individuals into pedigrees is not just a technical challenge but one with significant social, historical, and ethical dimensions that must be considered in applications of computational genetic genealogy.</p>
            
            <div class="learning-pathway">
                <p>This lab is part of the Bonsai v3 Deep Dive track:</p>
                <div class="pathway-steps">
                    <div class="pathway-step">
                        <h5>Introduction</h5>
                        <p>Lab 01</p>
                    </div>
                    <div class="pathway-step">
                        <h5>Architecture</h5>
                        <p>Lab 02</p>
                    </div>
                    <div class="pathway-step">
                        <h5>IBD Formats</h5>
                        <p>Lab 03</p>
                    </div>
                    <div class="pathway-step">
                        <h5>Statistics</h5>
                        <p>Lab 04</p>
                    </div>
                    <div class="pathway-step">
                        <h5>Models</h5>
                        <p>Lab 05</p>
                    </div>
                    <div class="pathway-step">
                        <h5>Relationships</h5>
                        <p>Lab 06</p>
                    </div>
                    <div class="pathway-step">
                        <h5>PwLogLike</h5>
                        <p>Lab 07</p>
                    </div>
                    <div class="pathway-step">
                        <h5>Age Modeling</h5>
                        <p>Lab 08</p>
                    </div>
                    <div class="pathway-step">
                        <h5>Data Structures</h5>
                        <p>Lab 09</p>
                    </div>
                    <div class="pathway-step">
                        <h5>Up-Node Dict</h5>
                        <p>Lab 10</p>
                    </div>
                    <div class="pathway-step">
                        <h5>Connection Points</h5>
                        <p>Lab 11</p>
                    </div>
                    <div class="pathway-step">
                        <h5>Relationship Assessment</h5>
                        <p>Lab 12</p>
                    </div>
                    <div class="pathway-step active">
                        <h5>Small Pedigrees</h5>
                        <p>Lab 13</p>
                    </div>
                </div>
            </div>

            <div class="lab-navigation">
                <a href="lab12_relationship_assessment.html" class="prev-lab">Relationship Assessment</a>
                <a href="lab14_optimizing_pedigrees.html" class="next-lab">Optimizing Pedigrees</a>
            </div>
        </article>
    </main>

    <footer class="textbook-footer">
        <div class="container">
            <p>&copy; 2025 Dr. LaKisha David, Department of Anthropology, University of Illinois Urbana-Champaign</p>
        </div>
    </footer>
</body>
</html>