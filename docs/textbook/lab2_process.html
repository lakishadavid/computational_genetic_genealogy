<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lab 3: Processing Raw DNA Profiles | Computational Genetic Genealogy</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <header>
        <h1>Computational Genetic Genealogy</h1>
        <p>Processing Raw DNA Profiles</p>
    </header>

    <nav class="main-nav">
        <a href="../index.html">Home</a>
        <a href="contents.html">Contents</a>
        <a href="lab3_process.html" class="active">Lab 3: Processing Raw DNA</a>
    </nav>

    <main class="container">
        <article class="section lab-content">
            <h2>Lab 3: Processing Raw DNA Profiles</h2>
            
            <div class="alert alert-info">
                <p><strong>Why This Matters:</strong> Direct-to-consumer genetic testing companies provide raw data in proprietary formats. To analyze this data for genealogical purposes, we need to convert it to standard bioinformatics formats like VCF that can be used with specialized genetic analysis tools.</p>
            </div>

            <h3>Learning Objectives</h3>
            <ul class="objectives-list">
                <li>Understand the structure of consumer DNA testing file formats</li>
                <li>Process and convert raw DNA profiles to standard VCF format</li>
                <li>Standardize genomic coordinates and reference alleles</li>
                <li>Merge multiple DNA profiles into a unified dataset</li>
                <li>Prepare converted data for downstream IBD analysis</li>
            </ul>

            <h3>Key Concepts</h3>
            
            <h4>Consumer DNA Testing Formats</h4>
            <p>Direct-to-consumer genetic testing companies like 23andMe, AncestryDNA, and others provide raw data in company-specific formats. While there are differences between formats, they typically include:</p>
            
            <table>
                <tr>
                    <th>Format Component</th>
                    <th>Description</th>
                    <th>Example</th>
                </tr>
                <tr>
                    <td>rsID</td>
                    <td>Reference SNP cluster ID</td>
                    <td>rs123456</td>
                </tr>
                <tr>
                    <td>Chromosome</td>
                    <td>Chromosome number (1-22, X, Y, MT)</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>Position</td>
                    <td>Genomic position</td>
                    <td>752566</td>
                </tr>
                <tr>
                    <td>Genotype</td>
                    <td>The alleles present (A, C, G, T)</td>
                    <td>AA, AG, etc.</td>
                </tr>
            </table>

            <h4>Example Consumer DNA Formats</h4>
            <p>Let's look at examples from common testing companies:</p>
            
            <pre><code># 23andMe Format
# rsid	chromosome	position	genotype
rs3094315	1	752566	AG
rs3131972	1	752721	GG
rs12562034	1	768448	GG
rs3115860	1	1158631	AA</code></pre>
            
            <pre><code># AncestryDNA Format
# rsid,chromosome,position,allele1,allele2
rs3094315,1,752566,A,G
rs3131972,1,752721,G,G
rs12562034,1,768448,G,G
rs3115860,1,1158631,A,A</code></pre>

            <h4>VCF Format</h4>
            <p>The Variant Call Format (VCF) is a standard format for storing genetic variation data. Converting to VCF enables compatibility with bioinformatics tools:</p>
            
            <pre><code>##fileformat=VCFv4.2
##source=consumer_dna_converter
##reference=GRCh37
##INFO=<ID=NS,Number=1,Type=Integer,Description="Number of Samples With Data">
##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">
#CHROM  POS     ID      REF     ALT     QUAL    FILTER  INFO    FORMAT  sample1
1       752566  rs3094315       A       G       .       PASS    NS=1    GT      0/1
1       752721  rs3131972       A       G       .       PASS    NS=1    GT      1/1
1       768448  rs12562034      A       G       .       PASS    NS=1    GT      1/1
1       1158631 rs3115860       A       C       .       PASS    NS=1    GT      0/0</code></pre>

            <h3>Processing Raw DNA Profiles</h3>
            
            <h4>Parsing Consumer DNA Files</h4>
            <p>First, we need to parse the raw DNA files based on their format:</p>
            
            <pre><code>import pandas as pd
import re
import os

def detect_dna_format(file_path):
    """Detect the format of a consumer DNA file by examining the first few lines."""
    with open(file_path, 'r') as f:
        header = ""
        for _ in range(15):  # Read up to 15 lines to find the header
            line = f.readline().strip()
            if line and not line.startswith('#'):
                header = line
                break
    
    if not header:
        return "unknown"
    
    # Check for common formats
    if re.match(r'rs\d+\s+\d+\s+\d+\s+[ACGT\-]+', header):  # 23andMe
        return "23andme"
    elif re.match(r'rs\d+,\d+,\d+,[ACGT\-],[ACGT\-]', header):  # AncestryDNA
        return "ancestry"
    elif re.match(r'rs\d+\t\d+\t[ACGT\-]+\t[ACGT\-]+', header):  # FTDNA
        return "ftdna"
    else:
        return "unknown"

def parse_consumer_dna(file_path, format_type=None):
    """Parse a consumer DNA file into a standardized DataFrame."""
    # Detect format if not provided
    if format_type is None:
        format_type = detect_dna_format(file_path)
    
    print(f"Detected format: {format_type}")
    
    # Parse based on format
    if format_type == "23andme":
        # Skip comment lines, use whitespace as delimiter
        df = pd.read_csv(file_path, comment='#', delim_whitespace=True,
                         names=["rsid", "chromosome", "position", "genotype"])
    
    elif format_type == "ancestry":
        # Skip comment lines, use comma as delimiter
        df = pd.read_csv(file_path, comment='#',
                         names=["rsid", "chromosome", "position", "allele1", "allele2"])
        # Combine alleles into genotype
        df["genotype"] = df["allele1"] + df["allele2"]
    
    elif format_type == "ftdna":
        # Skip comment lines, use tab as delimiter
        df = pd.read_csv(file_path, comment='#', sep='\t',
                         names=["rsid", "chromosome", "allele1", "allele2"])
        # FTDNA format doesn't include position, we'll need to look it up
        df["genotype"] = df["allele1"] + df["allele2"]
    
    else:
        raise ValueError(f"Unsupported or unrecognized format: {format_type}")
    
    # Clean up chromosome names
    df["chromosome"] = df["chromosome"].astype(str).str.replace("chr", "")
    
    return df</code></pre>

            <h4>Converting to VCF Format</h4>
            <p>Next, we need to convert the parsed data to VCF format, which requires reference allele information:</p>
            
            <pre><code>def load_reference_alleles(reference_file):
    """Load reference alleles for common SNPs from a reference file."""
    # Reference file should have rsid, chromosome, position, ref_allele columns
    ref_df = pd.read_csv(reference_file, sep='\t')
    # Create a dictionary for quick lookup
    ref_dict = {row["rsid"]: row["ref_allele"] 
               for _, row in ref_df.iterrows()}
    return ref_dict

def convert_to_vcf(dna_df, sample_id, reference_alleles, output_path):
    """Convert parsed DNA data to VCF format."""
    # Ensure we have all required columns
    if "rsid" not in dna_df.columns or "chromosome" not in dna_df.columns \
       or "position" not in dna_df.columns or "genotype" not in dna_df.columns:
        raise ValueError("DNA DataFrame missing required columns")
    
    # Filter to autosomal chromosomes for simplicity
    valid_chroms = [str(i) for i in range(1, 23)] + ["X", "Y"]
    filtered_df = dna_df[dna_df["chromosome"].isin(valid_chroms)].copy()
    
    # Sort by chromosome and position
    filtered_df = filtered_df.sort_values(["chromosome", "position"])
    
    # Determine ref and alt alleles
    vcf_records = []
    for _, row in filtered_df.iterrows():
        rsid = row["rsid"]
        chrom = row["chromosome"]
        pos = row["position"]
        genotype = row["genotype"]
        
        # Skip if missing genotype
        if genotype == "--" or genotype == "00" or pd.isna(genotype):
            continue
        
        # Get reference allele
        ref_allele = reference_alleles.get(rsid)
        if ref_allele is None:
            # Skip if we can't determine the reference allele
            continue
        
        # Determine alternate allele(s)
        alt_alleles = set(genotype) - {ref_allele}
        if not alt_alleles:
            alt_allele = "."
            gt = "0/0"  # Homozygous reference
        elif len(alt_alleles) == 1:
            alt_allele = list(alt_alleles)[0]
            if genotype[0] == genotype[1]:  # Homozygous alternate
                gt = "1/1"
            else:  # Heterozygous
                gt = "0/1"
        else:
            # Skip complex cases for simplicity
            continue
        
        vcf_records.append({
            "CHROM": chrom,
            "POS": pos,
            "ID": rsid,
            "REF": ref_allele,
            "ALT": alt_allele,
            "QUAL": ".",
            "FILTER": "PASS",
            "INFO": "NS=1",
            "FORMAT": "GT",
            sample_id: gt
        })
    
    # Convert to DataFrame for easier writing
    vcf_df = pd.DataFrame(vcf_records)
    
    # Write VCF file
    with open(output_path, 'w') as f:
        # Write VCF header
        f.write("##fileformat=VCFv4.2\n")
        f.write("##source=consumer_dna_converter\n")
        f.write("##reference=GRCh37\n")
        f.write('##INFO=<ID=NS,Number=1,Type=Integer,Description="Number of Samples With Data">\n')
        f.write('##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">\n')
        
        # Write column headers
        columns = ["CHROM", "POS", "ID", "REF", "ALT", "QUAL", "FILTER", "INFO", "FORMAT", sample_id]
        f.write('#' + '\t'.join(columns) + '\n')
        
        # Write data rows
        for _, row in vcf_df.iterrows():
            f.write('\t'.join([str(row[col]) for col in columns]) + '\n')
    
    print(f"Converted {len(vcf_records)} variants to VCF format in {output_path}")</code></pre>

            <h4>Processing Multiple Samples</h4>
            <p>To analyze relationships, we'll need to process multiple samples and merge them:</p>
            
            <pre><code>def process_dna_files(input_dir, output_dir, reference_alleles_file):
    """Process all DNA files in a directory and convert to VCF."""
    # Create output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    # Load reference alleles
    reference_alleles = load_reference_alleles(reference_alleles_file)
    
    vcf_files = []
    for filename in os.listdir(input_dir):
        if filename.endswith('.txt') or filename.endswith('.csv'):
            file_path = os.path.join(input_dir, filename)
            
            # Extract sample ID from filename
            sample_id = os.path.splitext(filename)[0]
            
            try:
                # Parse the DNA file
                dna_df = parse_consumer_dna(file_path)
                
                # Convert to VCF
                output_path = os.path.join(output_dir, f"{sample_id}.vcf")
                convert_to_vcf(dna_df, sample_id, reference_alleles, output_path)
                
                vcf_files.append(output_path)
                print(f"Successfully processed {filename}")
            
            except Exception as e:
                print(f"Error processing {filename}: {e}")
    
    return vcf_files</code></pre>

            <h4>Merging VCF Files</h4>
            <p>After converting individual files, we can merge them into a single dataset for joint analysis:</p>
            
            <pre><code>def merge_vcf_files(vcf_files, output_path):
    """Merge multiple VCF files into a single multi-sample VCF."""
    if not vcf_files:
        print("No VCF files to merge")
        return None
    
    # Use bcftools to merge VCF files
    cmd = f"bcftools merge --output-type v --output {output_path} {' '.join(vcf_files)}"
    print(f"Running: {cmd}")
    result = os.system(cmd)
    
    if result != 0:
        print("Error merging VCF files")
        return None
    
    print(f"Merged VCF files saved to {output_path}")
    return output_path</code></pre>

            <h4>Complete Workflow</h4>
            <p>Let's bring it all together into a complete workflow:</p>
            
            <pre><code>def main():
    """Main workflow to process raw DNA profiles."""
    # Define file paths
    input_dir = "data/raw_dna_profiles"
    output_dir = "results/processed_vcfs"
    reference_alleles_file = "references/common_snps_reference.txt"
    merged_output = "results/merged_samples.vcf"
    
    # Process all DNA files
    vcf_files = process_dna_files(input_dir, output_dir, reference_alleles_file)
    
    # Merge all processed VCF files
    merged_vcf = merge_vcf_files(vcf_files, merged_output)
    
    # Compress and index the merged VCF for downstream use
    if merged_vcf:
        os.system(f"bgzip -f {merged_vcf}")
        os.system(f"tabix -p vcf {merged_vcf}.gz")
        print(f"Compressed and indexed VCF: {merged_vcf}.gz")

if __name__ == "__main__":
    main()</code></pre>

            <h3>Handling Genomic Coordinate Systems</h3>
            <p>Different DNA testing companies may use different human genome reference builds (GRCh37/hg19 or GRCh38/hg38). We may need to convert between them:</p>
            
            <pre><code>def liftover_coordinates(input_vcf, output_vcf, chain_file):
    """Convert genomic coordinates from one reference build to another."""
    # Use CrossMap or LiftOver tool for coordinate conversion
    cmd = f"CrossMap.py vcf {chain_file} {input_vcf} references/GRCh38.fa {output_vcf}"
    result = os.system(cmd)
    
    if result != 0:
        print("Error performing coordinate liftover")
        return None
    
    print(f"Coordinates lifted over to new reference: {output_vcf}")
    return output_vcf</code></pre>

            <h3>Anthropological Context</h3>
            <p>Standardizing and merging DNA profiles is particularly important in anthropological research involving diverse individuals who may have tested with different companies. This process allows:</p>
            
            <ul>
                <li><strong>Cross-Platform Comparison:</strong> Identifying genetic relationships across different testing platforms</li>
                <li><strong>Historical Genealogy:</strong> Comparing genetic data from contemporary individuals with historical or archaeological samples</li>
                <li><strong>Community Reconstruction:</strong> For anthropologists studying the African diaspora, standardized DNA profiles enable the reconstruction of kinship networks disrupted by slavery and colonialism</li>
                <li><strong>Ethical Data Integration:</strong> Maintaining data provenance and privacy while enabling meaningful analysis</li>
            </ul>
            
            <p>By converting raw DNA profiles to standard formats, anthropologists can bridge the gap between consumer genetic testing and rigorous scientific analysis, enabling more comprehensive studies of human genetic relationships.</p>

            <h3>Exercises</h3>
            <ol>
                <li>Parse raw DNA files from different consumer testing companies</li>
                <li>Convert the parsed data to standardized VCF format</li>
                <li>Merge multiple VCF files into a single dataset</li>
                <li>Convert genomic coordinates between reference builds if needed</li>
                <li>Examine the merged dataset to identify shared genetic markers</li>
            </ol>

            <div class="alert alert-warning">
                <p><strong>Note:</strong> This lab assumes you have access to reference allele information for common SNPs. If not, you'll need to download this information from public databases like dbSNP or extract it from the 1000 Genomes Project reference.</p>
            </div>
            
            <div class="lab-navigation">
                <a href="lab2_exploring.html" class="prev-lab">Exploring Data</a>
                <a href="lab4_qc.html" class="next-lab">Quality Control</a>
            </div>
        </article>
    </main>

    <footer>
        <p>&copy; 2025 Dr. LaKisha David, Department of Anthropology, University of Illinois Urbana-Champaign</p>
    </footer>
</body>
</html>